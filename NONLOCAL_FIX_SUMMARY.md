# 非局域应变计算修复说明

## 问题诊断

原代码存在的问题：
1. **迭代重复累加问题**：在Abaqus隐式求解中，同一增量步内会有多次迭代，每次迭代都会调用所有积分点的UMAT
2. 原代码只在新增量步开始时重置累加器，导致同一增量步内的多次迭代会重复累加
3. 结果：`GRAIN_NPTS`和`EQVPL_SUM`被重复累加多次，导致晶粒平均值计算错误

## 解决方案

采用**迭代检测机制**来避免重复累加：

### 核心改进

1. **增加迭代计数器**：
   - 在MODULE PARABANK中增加`ITER_COUNT`变量
   - 用于跟踪当前增量步内的迭代次数

2. **迭代开始检测**：
   - 假设`NOEL=1`且`NPT=1`是每轮迭代的第一个调用点
   - 当检测到新一轮迭代开始时，重置累加器`EQVPL_SUM`和`GRAIN_NPTS`
   - 这样确保每次迭代只累加一次

3. **数据流程**：
   ```
   增量步N开始:
     - 用增量步N-1的累加数据计算EQVPL_AVG
     - 重置累加器
     - ITER_COUNT = 0

   增量步N的第1次迭代:
     - ITER_COUNT = 1
     - 所有积分点累加到EQVPL_SUM和GRAIN_NPTS

   增量步N的第2次迭代:
     - 检测到ITER_COUNT > 1，重置累加器
     - 所有积分点重新累加

   增量步N的第k次迭代:
     - 检测到ITER_COUNT > 1，重置累加器
     - 所有积分点重新累加

   增量步N+1开始:
     - 用增量步N最后一次迭代的累加数据计算EQVPL_AVG
     - 重复上述流程
   ```

## 代码修改详情

### 1. MODULE PARABANK (第211-222行)
```fortran
REAL*8 EQVPL_SUM(GRNUM)           ! 各晶粒内等效塑性应变累加和
REAL*8 EQVPL_AVG(GRNUM)           ! 各晶粒的平均等效塑性应变（非局部值）
INTEGER GRAIN_NPTS(GRNUM)         ! 各晶粒内积分点计数
INTEGER KINC_PREV                 ! 上一增量步编号（用于检测新增量步）
INTEGER ITER_COUNT                ! 迭代计数器（用于检测新迭代）
```

### 2. 状态变量定义 (第120-122行)
```fortran
C     | NSTATV - 26 ~ NSTATV - 14   | 各晶粒平均等效塑性应变(13个)      |
C     |                             | 用于非局部化孔隙率模型            |
```
用于存储晶粒平均值，便于后处理和调试。

### 3. 非局部化计算逻辑 (第311-359行)
主要改进：
- 新增量步开始时：计算平均值并重置累加器
- 同一增量步内：检测新迭代并重置累加器
- 每个积分点：累加到对应晶粒

### 4. 孔隙率演化部分 (第1097-1123行)
- 使用上一步的晶粒平均值`EQVPL_AVG(IGRAIN)`作为非局部值
- 累加当前积分点的EQVPL到晶粒累加器
- 将晶粒平均值存入状态变量（用于后处理）

## 注意事项

1. **NOEL=1且NPT=1的假设**：
   - 假设单元1的积分点1总是每轮迭代的第一个调用点
   - 这在大多数Abaqus模型中是成立的
   - 如果模型结构特殊，可能需要调整检测逻辑

2. **调试输出**：
   - 代码中包含调试输出语句（第1118-1122行）
   - 可以通过查看输出验证迭代计数是否正确
   - 验证后可以注释掉以提高性能

3. **状态变量数量**：
   - 确保INP文件中的`*DEPVAR`定义了足够的状态变量
   - 需要至少`NSTATV >= 30*ND + 30`（当ND=42时，至少1290个）

## 验证建议

运行模型后，检查输出文件中的调试信息：
```
Nonlocal: New increment KINC= 2
  Grain 1 avg= 0.00123
KINC= 2  ITER= 1  Porosity= 0.001  EQVPL= 0.00125  EQVPL_NL= 0.00123
KINC= 2  ITER= 2  Porosity= 0.001  EQVPL= 0.00126  EQVPL_NL= 0.00123
```

确认：
1. 每个新增量步都会更新EQVPL_AVG
2. ITER计数器在同一增量步内递增
3. EQVPL_NL（非局部值）在同一增量步内保持不变
4. EQVPL（局部值）在迭代过程中变化

## 理论依据

这种实现方式基于：
1. **隐式梯度非局部模型**：使用晶粒平均值作为非局部正则化
2. **滞后一步策略**：当前步使用上一步的平均值，避免隐式耦合
3. **迭代一致性**：确保每次迭代使用相同的非局部值，保证收敛性

## 修改日期
2026-01-26

## 修改人
Claude Sonnet 4.5
